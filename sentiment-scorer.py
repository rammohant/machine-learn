# Tara Ram Mohan 
# CMSC 416 Programming Assignment 4: Scorer for Sentiment Analysis
# April 25, 2022
###########################################################
# Problem: This Python program called scorer.py will take 2 files as input (a sense tagged output generated from wsd.py and the gold standard "gold_file" data). 
# It will report the overall accuracy of my sense tagging based on the gold standard and print a confusion matrix 
###########################################################
# Usage: To start the program, run the following command: 
# python3 scorer.py my-sentiment-answers.txt sentiment-test-key.txt where (my-sentiment-answers.txt) contains the senses from the test file generated by wsd.py and (sentiment-test-key.txt) is the gold standard gold_file. 
# Example command: python3 scorer.py my-sentiment-answers.txt sentiment-test-key.txt
# All of the following are portions (not the entire file example) of the actual file.
# Example input my-sentiment-answers.txt: 
  # <answer instance=620979391984566272 sentiment="negative"/>
  # <answer instance=621340584804888578 sentiment="positive"/>
  # <answer instance=621351052047028224 sentiment="positive"/>
# Example input sentiment-test-key.txt:
  # <answer instance="620979391984566272" sentiment="negative"/>
  # <answer instance="621340584804888578" sentiment="negative"/>
  # <answer instance="621351052047028224" sentiment="negative"/>
# Example output: 
  # Accuracy:  0.728448275862069
  # Confusion Matrix:
  #                    Predicted: positive  Predicted: negative
  # Actual: positive                  140                   43
  # Actual: negative                   20                   29
###########################################################
# Algorithm: 
# (1) The program will read all the files outlined in the user input. This includes my sense tagged output and the gold standard text output
# (2) For each text file, the program iterates through each line in the file, converting it into a singular string. Using a regex expression, we will extract just the sense tag from each sentence and add it to the output array.
# This step will produce 2 arrays containing the actual sense sense tags from my sense tagged output and the expected senses from the gold standard text output
# (3) The program calculates and outputs accuracy given actual and expected sense tags. 
# To do so, we iterate through the actual sense tags array counting the total number of sense tags as (TP + TN + FP + FN). For each 'actual' sense tag that matches the corresponding 'expected' tag, we increment (TP + TN) by 1. 
# Then, we calculate accuracy as (TP + TN) / (TP + TN + FP + FN)
# (4) The program creates confusion matrix given actual and expected sense tags. The actual confusion matrix will be created using sklearn.metrics, the array of actual sense tags, and the array of expected sense tags and then converted into a pandas dataframe to be outputted.
###########################################################
import re
import pandas as pd
import sys
from sklearn.metrics import confusion_matrix


# Function that takes in a filename and iterates through each line in the file, converting it into a singular string. 
def convert_to_text(file): 
    lines = []
    output_text = ''

    with open(file, "r") as f:
        for line in f:
          lines.append(line.strip())
        output_text = ' '.join(lines)
      
    # Use regex to get just the senses
    find_sense = re.compile(r'<\s*answer.*?sentiment\s*=\s*"(.*?)".*?>')
    
    # Return all senses from file
    output_list = find_sense.findall(output_text)
      
    return output_list

# Function that will take in the accuracy using the following equation: accuracy = (TP + TN) / (TP + TN + FP + FN) and creates 2 lists one containing the actual sense tags and the other containing the expected sense tags
def calculate_accuracy(actual, expected):
    tp_tn = 0
    tp_tn_fp_fn = 0
    y_true = []
    y_pred = []
    
    # For each sense tag in my 'actual' tagged output
    for i in range(len(actual)):
        phone_sense = re.search(r'phone', expected[i])
      
        # Add to total num of senses (TP + TN + FP + FN)
        tp_tn_fp_fn += 1 
        
        # If expected and actual are the same, add to correct output count (tp+tn)
        if actual[i] == expected[i]:
            tp_tn+=1

    accuracy = tp_tn/tp_tn_fp_fn
    return accuracy
            
# Function that creates 
def create_cm(actual,expected):

    # Get all unique sense tags
    indices = list(set(actual))
  
    # Using sklearn.metrics, create a confusion matrix
    cm = confusion_matrix(actual,expected, labels = indices)

    # Format the confusion matrix appropriately with the right column and row headers
    cm_df = pd.DataFrame(cm,
                     index = ['Actual: ' + i for i in indices], 
                     columns = ['Predicted: ' + i for i in indices] )
  
    return indices, cm, cm_df

if __name__ == '__main__':
    # Step 1: Read in command line args
    my_file = sys.argv[1] # My pos tagged output
    gold_file = sys.argv[2] # Gold standard gold_file output
  
    # Step 2: Convert contents of each file into a string and get an array of just senses 
    y_true = convert_to_text(my_file)
    y_pred = convert_to_text(gold_file)
    
    # Step 3: Calculate and output accuracy given actual and expected senses
    accuracy = calculate_accuracy(y_true, y_pred)
    print("Accuracy: ", accuracy)

    # Step 4: Create confusion matrix given actual and expected senses
    indices, cm, cm_df = create_cm(y_true, y_pred)
  
    # Step 5: Output confusion matrix 
    print('Confusion Matrix:\n',cm_df)
